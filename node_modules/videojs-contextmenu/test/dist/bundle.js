(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"min-document":1}],3:[function(require,module,exports){
(function (global){
/**
 * @module plugin
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _videoJs = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _videoJs2 = _interopRequireDefault(_videoJs);

// vjs 5/6 cross compatibility.
var registerPlugin = _videoJs2['default'].registerPlugin || _videoJs2['default'].plugin;

/* eslint func-style: 0 */

var defaults = {
  cancel: true,
  sensitivity: 10,
  wait: 500,
  disabled: false
};

var EVENT_NAME = 'vjs-contextmenu';

/**
 * Abstracts a DOM standard event into a vjs-contextmenu event.
 *
 * @private
 * @param  {Player} player
 * @param  {Event} event
 *         A triggering, native event.
 * @return {Player}
 */
function sendAbstractedEvent(player, event) {
  if (player.contextmenu.options.disabled) {
    // videojs-contextmenu is disabled
    return player;
  }
  var abstracted = {
    target: player,
    type: EVENT_NAME
  };

  ['clientX', 'clientY', 'pageX', 'pageY', 'screenX', 'screenY'].forEach(function (k) {
    abstracted[k] = event[k];
  });

  return player.trigger(abstracted);
}

/**
 * Handles both touchcancel and touchend events.
 *
 * @private
 * @param  {Event} e
 */
function handleTouchEnd(e) {
  var current = this.contextmenu.current;

  if (!current) {
    return;
  }

  var wait = this.contextmenu.options.wait;

  if (e.type === 'touchend' && Number(new Date()) - current.time >= wait) {
    sendAbstractedEvent(this, e);
  }

  this.contextmenu.current = null;
}

/**
 * Handles touchmove events.
 *
 * @private
 * @param  {Event} e
 */
function handleTouchMove(e) {
  var current = this.contextmenu.current;

  if (!current) {
    return;
  }

  var touch = e.touches[0];
  var sensitivity = this.contextmenu.options.sensitivity;

  // Cancel the current touch if the pointer has moved in either direction
  // more than the sensitivity number of pixels.
  if (touch.screenX - current.screenX > sensitivity || touch.screenY - current.screenY > sensitivity) {
    this.contextmenu.current = null;
  }
}

/**
 * Handles touchstart events.
 *
 * @private
 * @param  {Event} e
 */
function handleTouchStart(e) {

  // We only care about the first touch point.
  if (this.contextmenu.current) {
    return;
  }

  var touch = e.touches[0];

  this.contextmenu.current = {
    screenX: touch.screenX,
    screenY: touch.screenY,
    time: Number(new Date())
  };
}

/**
 * Handles contextmenu events.
 *
 * @private
 * @param  {Event} e
 */
function handleContextMenu(e) {
  if (this.contextmenu.options.cancel && !this.contextmenu.options.disabled) {
    e.preventDefault();
  }

  sendAbstractedEvent(this, e);

  // If we get a "contextmenu" event, we can rely on that going forward
  // because this client supports it; so, we can stop listening for
  // touch events.
  this.off(['touchcancel', 'touchend'], handleTouchEnd);
  this.off('touchmove', handleTouchMove);
  this.off('touchstart', handleTouchStart);
}

/**
 * A cross-device context menu implementation for video.js players.
 *
 * @param    {Object}  [options={}]
 * @param    {Boolean} [cancel=true]
 *           Whether or not to cancel the native "contextmenu" event when
 *           it is seen.
 *
 * @param    {Number} [sensitivity=10]
 *           The maximum number of pixels a finger can move because a touch
 *           is no longer considered to be "held".
 *
 * @param    {Number} [wait=500]
 *           The minimum number of milliseconds a touch must be "held" before
 *           it registers.
 */
function contextmenu(options) {
  var _this = this;

  this.contextmenu.options = _videoJs2['default'].mergeOptions(defaults, options);
  this.contextmenu.VERSION = '1.2.2';

  this.on('contextmenu', handleContextMenu);
  this.on(['touchcancel', 'touchend'], handleTouchEnd);
  this.on('touchmove', handleTouchMove);
  this.on('touchstart', handleTouchStart);

  this.ready(function () {
    return _this.addClass(EVENT_NAME);
  });
}

registerPlugin('contextmenu', contextmenu);
contextmenu.VERSION = '1.2.2';

exports['default'] = contextmenu;
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],4:[function(require,module,exports){
(function (global){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalDocument = require('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _qunit = (typeof window !== "undefined" ? window['QUnit'] : typeof global !== "undefined" ? global['QUnit'] : null);

var _qunit2 = _interopRequireDefault(_qunit);

var _sinon = (typeof window !== "undefined" ? window['sinon'] : typeof global !== "undefined" ? global['sinon'] : null);

var _sinon2 = _interopRequireDefault(_sinon);

var _videoJs = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _videoJs2 = _interopRequireDefault(_videoJs);

var _srcPlugin = require('../src/plugin');

var _srcPlugin2 = _interopRequireDefault(_srcPlugin);

var Player = _videoJs2['default'].getComponent('Player');

_qunit2['default'].test('the environment is sane', function (assert) {
  assert.strictEqual(typeof Array.isArray, 'function', 'es5 exists');
  assert.strictEqual(typeof _sinon2['default'], 'object', 'sinon exists');
  assert.strictEqual(typeof _videoJs2['default'], 'function', 'videojs exists');
  assert.strictEqual(typeof _srcPlugin2['default'], 'function', 'plugin is a function');
});

_qunit2['default'].module('videojs-contextmenu', {

  beforeEach: function beforeEach() {

    // Mock the environment's timers because certain things - particularly
    // player readiness - are asynchronous in video.js 5. This MUST come
    // before any player is created; otherwise, timers could get created
    // with the actual timer methods!
    this.clock = _sinon2['default'].useFakeTimers();

    this.fixture = _globalDocument2['default'].getElementById('qunit-fixture');
    this.video = _globalDocument2['default'].createElement('video');
    this.fixture.appendChild(this.video);
    this.player = (0, _videoJs2['default'])(this.video);
    this.player.contextmenu();
    this.spy = _sinon2['default'].spy();
    this.player.on('vjs-contextmenu', this.spy);

    // Tick the clock forward enough to trigger the player to be "ready".
    this.clock.tick(1);
  },

  afterEach: function afterEach() {
    this.player.dispose();
    this.clock.restore();
  }
});

_qunit2['default'].test('registers itself with video.js', function (assert) {
  assert.strictEqual(typeof Player.prototype.contextmenu, 'function', 'videojs-contextmenu plugin was registered');

  assert.ok(this.player.hasClass('vjs-contextmenu'), 'the plugin adds a class to the player');
});

_qunit2['default'].test('sends a "vjs-contextmenu" event when a native "contextmenu" event occurs', function (assert) {
  assert.notOk(this.spy.called, '"vjs-contextmenu" has not been triggered yet');
  this.player.trigger('contextmenu');
  assert.ok(this.spy.calledOnce, '"contextmenu" triggered a "vjs-contextmenu"');
});

_qunit2['default'].test('sends a "vjs-contextmenu" on long touch', function (assert) {
  this.player.trigger({
    type: 'touchstart',
    touches: [{
      screenX: 1,
      screenY: 1
    }]
  });

  this.clock.tick(1000);
  assert.notOk(this.spy.called, '"vjs-contextmenu" was not triggered between "touchstart" and "touchend"');
  this.player.trigger({ type: 'touchend' });
  assert.ok(this.spy.calledOnce, '"vjs-contextmenu" was triggered once a "touchend" triggered');
});

_qunit2['default'].test('stops listening for touches if it encounters a native "contextmenu" event', function (assert) {
  assert.notOk(this.spy.called, '"vjs-contextmenu" has not been triggered yet');
  this.player.trigger('contextmenu');
  assert.ok(this.spy.calledOnce, '"contextmenu" triggered a "vjs-contextmenu"');

  this.player.trigger({
    type: 'touchstart',
    touches: [{
      screenX: 1,
      screenY: 1
    }]
  });

  this.clock.tick(1000);

  this.player.trigger({
    type: 'touchend'
  });

  assert.ok(this.spy.calledOnce, 'touches did not trigger a second "vjs-contextmenu"');
  this.player.trigger('contextmenu');
  assert.ok(this.spy.calledTwice, '"contextmenu" triggered a second "vjs-contextmenu"');
});

_qunit2['default'].test('will not fire "vjs-contextmenu" if the touch point has moved beyond the sensitivity range in either direction', function (assert) {
  this.player.trigger({
    type: 'touchstart',
    touches: [{
      screenX: 1,
      screenY: 1
    }]
  });

  this.player.trigger({
    type: 'touchmove',
    touches: [{
      screenX: 12,
      screenY: 1
    }]
  });

  this.clock.tick(1000);

  this.player.trigger({
    type: 'touchend'
  });

  assert.notOk(this.spy.called, '"vjs-contextmenu" was not triggered because the touch point moved');

  this.player.trigger({
    type: 'touchstart',
    touches: [{
      screenX: 1,
      screenY: 1
    }]
  });

  this.player.trigger({
    type: 'touchmove',
    touches: [{
      screenX: 1,
      screenY: 12
    }]
  });

  this.clock.tick(1000);

  this.player.trigger({
    type: 'touchend'
  });

  assert.notOk(this.spy.called, '"vjs-contextmenu" was not triggered because the touch point moved');
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../src/plugin":3,"global/document":2}]},{},[4]);
